# 코드에서 나는 악취
> 개발 서적을 읽어 봤거나 관심이 있다면 한번 쯤은 들어봤을 제목명이다. '코드에서 나는 악취', '냄새나는 코드' 표현이 직설적이라 모르는 사람들은 오해할 수 있다. 표현이 어찌 되었든간에 chapter03 '코드에서 나는 악취'에서는 켄트 벡과 마틴 파울러가 어떤 쓰레기를 주워서 버리는지 확인할 수 있다.
> chapter01에서는 리팩터링의 quick start를 통해 리팩터링의 예시를 확인했고, chapter02에서는 '리팩터링은 이렇게 접근해야한다.'를 살펴봤다. 이번 chapter03에서는 '이런걸 리팩터링 해볼 수 있다.'를 말하는것 같다.

## 기이한 이름
함수, 모듈, 변수, 클래스의 이름만 보고 각가 무슨 일은 하고 어떻게 사용하는지 명확히 알 수 있어야 한다.
## 중복 코드
코드가 중복되면 하나로 통합한다. 통합할 때 서로 차이점은 없는지 확인한다.
- 한 클래스에 2개의 메서드가 똑같은 표현식을 사용할 때
    - **함수 추출하기**를 사용하여 추출된 메서드를 호출한다.
- 코드가 비슷한다 완전 똑같지 않다.
    - **문장 슬라이드하기**로 비슷한 부분을 한곳에 모아 추출한다.
- 같은 부모로부터 파생된 서브 클래스가 중복일 경우
    - **메서드 올리기**를 적용해 부모로 옮긴다.
## 긴 함수
초장기에는 서브루틴을 호출하는 비용이 커서 짧은 함수를 꺼렸지만 요즘은 그렇지 않다.
설명을 위해 주석을 작성하지 말고 의도가 들어나게 함수를 추출하여라
## 긴 매개변수 목록
긴 매개변수 목록은 그 자체로 이해하기 어려울 때가 있다. 이럴 때는 **매개변수를 질의 함수로 바꾸기**, **객체 통째로 넘기기**, **매개변수 객체 만들기** 등으로 매개변수 목록을 줄이면 좋다.
## 전역 데이터
전역 데이터는 누가 변경하였는지 찾기 어렵기 때문에 끊임없는 버그를 만드는 원인이 된다.
이를 방지하기 위해 **변수 캡슐화하기**를 이용하면 데이터를 수정하는 부분을 쉽게 찾을 수 있고, 접근을 통제할 수 있다.
## 가변 데이터
데이터를 변경할 수 있으면 골치 아픈 버그로 이어질 수 있다. 이런 버그가 드문 조건에서만 발생한다면 원인을 찾기 어렵다. 무분별한 데이터 수정을 줄이는 방법을 택해라
1. **변수 캡술화하기**를 적용하여 정해진 함수로 값을 수정할 수 있도록 통제해라
2. 하나의 변수에 용도가 다른 값들을 갱신하는 경우라면 **변수 쪼개기**를 이용하여 독립 변수에 저장해라
3. 갱신 로직을 다른 코드와 떨어뜨려 놓기 위해 **문장 슬라이드하기**, **함수 추출하기**를 이용해서 부작용 없는 코드를 분리해라
4. **세터 제거하기**를 적용하는 것마능로도 변수의 유효범위를 줄이는데 효과적이다.
5. 다른 곳에서 설정할 수 있는 가변 데이터는 **파생 변수를 질의 함수로 바꾸기**를 통해 코드 전체에 골고루 뿌려라
6. 가변 변수의 유효범위가 넓어질 땐 **여러 함수를 클래스로 묶기**, **여러 함수를 변환 함수로 묶기**를 활용해서 유효범위를 제한해라
7. 구조체 처럼 내부 필드에 데이터를 담고 있는 변수는 일반적으로 **참조를 값으로 바꾸기**를 적용하여 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체해라
## 뒤엉킨 변경
소프트웨어는 소프트 해야한다. 수정할 부분 딱 한군데를 찾아서 그 부분만 수정할 수 있어야 한다. 그렇게 할 수 없다면 뒤엉킨 변경과 산탕총 수술중 하나의 악취가 풍긴다. 보통 단일 책임의 원칙이 지켜지지 않았을 경우에 이러한 현상이 발생한다.
맥락에 해당하는 적당한 모듈들을 만들어 관련 함수들을 분리한다.
## 산탄총 수술
변경할 부분이 코드 전반에 퍼져 있다면 수정할 곳을 찾기 힘들다.
함께 변경되는 대상들은 한 모듈에 모으면 좋다.
- 비슷한 데이터를 다루는 함수가 많다.
    - **여러 함수를 클래스로 묶기**를 적용한다.
- 데이터 구조를 변환하거나 enrich 하는 함수
    - **여러 함수를 변환 함수로 묶기**를 적용한다.
- 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계로 전달할 수 있다.
    - **단계 쪼개기**를 적용한다.
## 기능 편애
어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작요을 할 일이 더 많을 때
**함수 옮기기**, **함수 추출하기**를 이용하여 하나의 모듈로 모은다.
## 데이터 뭉치
데이터는 클래스로 관리하여 생산성에 기여하도록 한다.
## 기본형 집착
금액을 그냥 숫자형으로 계산하거나 물리량을 계산할 때 단위를 무시한다.
최소한 사용자에게 보여줄 때는 일관된 형식으로 출력해주는 기능이라도 갖춰야한다.
**기본형을 객체로 바꾸기**를 적용하면 기본형에서 객체로 바꾸어라 (일급 컬렉션, 도메인 컬렉션과 비슷한 방식인가?)
## 반복되는 switch문
switch문 자제의 문제보단 중복된 switch문이 문제다. 조건절이 하나 추가될 때 마다 다른 switch문에도 추가해야하는 문제가 발생한다.
## 반복문
filter나 map같은 파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.
## 성의 없는 요소
리팩터링을 거치면서 역할이 줄어든 필요없는 함수, 클래스 인터페이스 등을 삭제해라
삭제에 도움이 되는 리팩터링 방법
1. 함수 인라인하기
2. 클래스 인라인 하기
3. 계층 합치기
## 추측성 일반화
미래에 대비해 작성한 부분이 실제로 사용되지 않는다면 쓸데없는 낭비다.
- 하는 일이 거의 없는 추상 클래스
    - **계층 합치기**로 제거한다.
- 쓸떼없이 위임하는 코드
    - **함수 인라인하기**나 **클래스 인라인하기**로 삭제
- 본문에서 사용됮 ㅣ않는 매개변수
    - **함수 선언 바꾸기**로 없앤다.
## 임시 필드
객체를 가져올 때는 모든 필드가 채워져 있으리라 기대한다. 그런데 임시 필드가 있을 경우 코드를 이해하기 힘들다.
임시 필드가 유효하지 않을 때를 위한 대안 클래스를 만들어라
## 메시지 체인
aPerson.department.managerName와 같은 변수들이 있을 경우 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다. 그래서 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야한다. 이 문제를 해결하기 위해 **위임 숨기기**로 해결한다.
```
managerName = aPerson.department.manager.name
managerName = aPerson.manager.name
managerName = aPerson.managerName
```
## 중개자
클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 **중개자 제거하기**를 활용하여 실제로 일을 하는 객체와 직접 소통하게 하자.
## 내부자 거래
모듈의 결합도를 낮추기 위해 같은 관심사를 공유하는 공통 부분을 처리하는 제3의 모듈을 만들거나 **위임 숨기기**를 이용하여 다른 모듈이 중간자 역할을 하게 만든다.
상속 구조에서 부모 자식 사이에 결탁이 생길 때, 자식 클래스는 항상 부모 클래스가 공개하고 싶은 것 이상으로 부모에 대해 알려고 한다. 이때 **서브클래스를 위임으로 바꾸기**, **슈퍼클래스를 위임으로 바꾸기**를 활용하자.
## 거대한 클래스
접두어나 접미어가 같은 필드들이 함게 추출한 후보다. 이렇게 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는게 좋다면 **슈퍼클래스 추출하기**, **타입 코드를 서브클래스로 바꾸기**를 적용한다.
## 서로 다른 인터페이스의 대안 클래스들
클래스를 사용할 때 큰 장점은 필요에 따라 다른 클래스를 교체할 수 있다. 단, 교체하려면 인터페이스가 같아야 한다.
1. **함수 선언 바꾸기**로 메서드 시그니처를 일치시킨다.
2. **함수 옮기기**를 이용하여 인터페이스가 같아질 때 까지 옮긴다.
3. 중복 코드가 생기면 **슈퍼클래스 추출하기**를 고려한다.
## 데이터 클래스
1. public 필드가 있다면 **레코드 캡슐화하기**로 숨기자
2. 변경하면 안되는 필드는 **세터 제거하기**로 차단한다.
## 상속 포기
계층구조를 잘못 설계했을 때 자식 클래스에서 필요없는 부모 클래스 메서드와 데이터가 있을 수 있다.
1. 같은 계층에 서브클래스를 만들고 **메서드 내리기**, **필드 내리기**를 활용해서 필요없는 부모 코드를 서브 클래스로 넘긴다.
2. 서브 클래스가 부모 코드가 필요하지만 인터페이스는 따르고 싶지 않을 때 **서브클래스를 위임으로 바꾸기**, **슈퍼클래스를 위임으로 바꾸기**를 활용하여 상속 메커니즘에서 벗어난다.
## 주석
1. 특정 코드블록이 하는 일에 주석을 남기고 싶다면 **함수 추출하기**를 적용한다.
2. 이미 추출된 함수임에도 여전히 설명이 필요하면 **함수 선언 바꾸기**로 함수 이름을 바꾼다.
3. 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 **어서션 추가하기**를 한다.
