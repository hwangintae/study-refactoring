## 리팩터링 정의
> ~하다. [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

코드를 정리하는 작업을 리팩터링이라 하지 않고, 특정한 방식에 따라 코드를 정리하는 것만이 **리팩터링** 이다.

리팩터링하는 동안에 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

코드베이스를 정리하거나 구조를 바꾸는 것 -> 재구성 (restructuring)
리팩터링은 재구성의 일부분

함수 추출하기를 통해 콜스텍이 달라져 성능이 변할 수 있지만 사용자 관점에서는 달라지는 점이 없어야 한다.

## 두개의 모자
기능 추가 : 기존 코드는 절대 건드리지 않고 오직 기능만 추가한다.
리팩터링 : 기능 추가는 절대로 하지 않고 오로지 코드 재구성에만 전념한다.

개발하는 동안 기능 추가를 할지 리팩터링을 할지 자주 바뀌긴 하지만 미묘한 작업 방식의 차이를 분명하게 하고 진행한다.

## 리팩터링하는 이유
#### 1. 소프트웨어 설계가 좋아진다.
- 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하면 기반 구조가 무너지기 쉽다.
- 설계가 나쁘면 같은 일을 하더라도 코드가 길어진다.
- 코드량이 줄어든다고 시스템이 빨라지는 것은 아니지만, 수정하는데 드는 노력은 크게 달라진다.
#### 2. 소트프웨어를 이해하기 쉬워진다.
- 코드의 목적이 더 잘 드러나게, 내 의도를 더 명확하게 전달하도록 개선할 수 있다.
#### 3. 버그를 쉽게 찾을 수 있다.
- '이럴 것이다'라고 가정하던 점들이 분명하게 드러나면서 버그를 지나칠 수 없을 정도로 명확해진다.
#### 4. 프로그래밍 속도를 높일 수 있다.
- 초기에는 진척이 빨랐지만 나중에는 새 기능을 하나 추가하는데 오랜 시간이 걸린다.
- 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.
- 코드가 명확하면 버그를 만들 가능성이 준다.

## 언제 리팩터링해야 할까?
#### 3의 법칙
> 비슷한 일을 세 번째 하게 되면 리팩터링한다.
#### 1. 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
- 구조를 살짝 바꾸면 기능 추가하기 쉬워질 만한 부분을 찾는다.
- 오류를 일으키는 코드가 세 곳에 복제되어 있다면 리팩터링을 한다.
#### 2. 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
- 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지를 찾는다.
- 코드를 분석할 때 리팩터링을 한다. (코드를 깊은 수준까지 이해하게 된다.)
#### 3. 쓰레기 줍기 리팩터링
- 비효율적으로 처리하는 부분을 발견하였을 때 하려던 작업과 관련이 있으면 하고, 없으면 주석을 달고 나중에 처리한다.
- 처음 왔을 때 보다 깔끔하게 정리하고 떠나자 (**캠핑 규칙**)
#### 4. 계획된 리팩터링과 수시로 하는 리팩터링
- 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈한다.
- 계획된 리팩터링은 상황에 따라 오래 걸릴 수 있기 때문에 수시로 리팩터링을 하여 최소한으로 계획된 리팩터링을 하자.
- 커밋을  할때  리팩터링과 기능 수정을 나눠서 할지 같이 할지 팀원들과 합의하라
#### 5. 오래 걸리는 리팩터링
- 팀 전체가 리팩터링을 하는 것 보다 주어진 문제를 몇 주에 걸쳐 조금씩 해결한다.
- 누구든지 원하는 방향으로 조금씩 개선한다.
#### 6. 코드 리뷰에 리팩터링 활용하기
- PR할 때 리팩터링을 활용하여 리뷰를 하는것 보다
- pair programming을 할 때 리팩터링을 활용하여 리뷰를 해보자.
#### 7. 관리자에게는 뭐라고 말해야 할까?
- 개발자 관점에서는 리팩터링은 개발 시간을 단축시키지만
- 관리자 관점에서는 리팩터링을 불신할 수 있다.
- 설득에 어려움이 있다면 말하지 말고 하자.
#### 8. 리팩터링하지 말아야 할 때
- 굳이 수정할 필요가 없으면 하지 않는다.
- 다시 만드는게 빠를 때

## 리팩터링 시 고려할 문제
#### 1. 새 기능 개발 속도 저하
- 리팩터링은 개발 속도를 높이기 위한 작업이다.
- 간단한 기능을 추가할 때 리팩터링으로 기능 추가가 더 쉬워진다면 리팩터링을 먼저 한다.
- 리팩터링은 코드를 이쁘게 꾸미는 것이 아닌 경제적인 이유로 하는 것이다.
#### 2. 코드 소유권
- 코드의 소유권으로 함수 이름 조차 바꾸기 힘들 경우가 있다.
- 코드의 소유권을 개인이 아닌 팀으로 정하여 팀원이라면 누구든지 수정할 수 있는 권한이 있어야 한다.
#### 3. 브랜치
- 복잡한 머지 문제를 해결하기 위해 소스 코드를 자주 통합한다.
#### 4. 테스팅
- 리팩터링을 하는 동안에 불안감을 해소할 수 있으며, 버그도 쉽게 발견할 수 있다.
#### 5. 레거시 코드
- 레거시 시스템은 테스트 코드 없이 리팩터링을 하기 쉽지 않다.
#### 6. 데이터베이스
- 새 필드를 사용하도록 변환해야 하는 부담이 있다.
- 변환을 수행하는 코드를 작성, 선언된 데이터 구조나 접근 루틴을 변경하는 코드를 commit
- 데이터베이스를 다른 버전으로 이전할 때마다 모든 마이그레이션 스크립트 실행
- 핵심은 작고 독립된 단계들로 쪼개는 것
- 프로덕션 환경에 여러 단계로 나눠서 릴리즈 하는게 좋다.
    1. 새로운 데이터베이스 필드를 추가한다.
    2. 기존 필드와 새 필드를 동시에 업데이트 하도록 한다.
    3. 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체한다.
    4. 필요없어진 필드는 삭제한다.
## 리팩터링, 아키텍처, 애그니(YAGNI)
1. 유연성 메커니즘을 소프트웨어에 심어두어라
2. 간결한 설계, 점진적 설계를 해라
3. 당장 필요한 기능만 최대한 간결하게 만들어라
## 리팩터링과 소프트웨어 개발 프로세스
1. 애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어야 한다.
## 리팩터링과 성능
- 성능에 신경 쓰지 않고 리팩터링을 하면서 코드를 다루기 쉽게 만드는게 먼저다.
- 최적화 단계에서 성능 테스트를 끝내고 최적화를 한다.
## 리팩터링의 유래
- 리팩터링의 정확한 유래는 없지만 XP가 스몰토크 커뮤니티에 큰 반향을 일으키면서 중요한 요소로 자리 잡았다.
## 리팩터링 자동화
- 리팩터링을 지원하는 IDE를 사용하여 리팩터링을 하여라.